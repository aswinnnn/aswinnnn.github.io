{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"weheartpy A fast, reliable API client for WeHeartIt. Description weheartpy is an unofficial API client for weheartit WeHeartIt does not have an API. So I have to make use of BeautifulSoup and requests to do my job. The speed is optimal, it has a limitation on number of results you can retreive through one search but its functional. Requirements requires Python 10.* or above. read the requirements here you can easily install the packages using pip Installation pip install weheartpy or pip install git+https://github.com/aswinnnn/weheartpy.git Features with weheartpy, you can search for: - posts aka entries - collections (including images inside them) - users - popular entries I'm adding more functionalities and utilities later on, but this is all we got for now. Usage this is the most basic usage of the weheartpy module. # import the main class from weheartpy import WeHeartIt whi = WeHeartIt () # create an instance of WeHeartIt entries = whi . popular () # returns a list of recent popular images from homepage. for entry in entries : print ( entry . image , entry . views , entry . creator . username ) # view the entry's contents print ( entry . hearts , entry . title ) entry . save ( \"\\images\\cool_pic_from_weheartit.jpeg\" ) # save the image from the post locally. parameters - None returns - List[ Entry ] a list of Entry objects which help you access the entries easier. errors - ConnectionError Posts / Entries search for entries. entries = whi . search_entries ( \"mean girls\" , sort = \"most_popular\" ) # returns a list of entries relevant to your query. for entry in entries : print ( entry . username , entry . image , entry . url ) parameters - query - your search query returns - List[ Entry ] a list of Entry objects which help you access the entries easier. errors - ConnectionError Collections # return a list of `Collection` objects resulting from the query. from weheartpy import WeHeartIt whi = WeHeartIt () cocs = whi . search_collections ( \"anime pfp\" ) for c in cocs : print ( c . title , c . link ) collection = c . get_full_collection () print ( collection . images , collection . description ) # save the images from a collection to a folder: collection . save ( \"\\collection \\\" ) # images will be saved as \"collection0.jpeg\", \"collection1.jpeg\", etc. parameters - query aka the search term returns - List[ Collection ] Check out the documentation to see what else you can do with Collection objects. errors - NoCollectionsFound Documentation check out the documentation for more usages. If you'd like to add something or fix mistakes, feel free to open an issue or a pull request. Updates v0.2.3 - using user-agent has been made default. Fixed major bug in search_entries so you might wanna update to this version to use that correctly. v0.2.2 - Big update, the library uses weheartit's natural API to bring Entry data. this features a whole new ton of information you can use from entries such as a views, hearts, tags, titles and creation dates. It also includes a .creator attribute which is a User object of the creator of the post. If you notice anything slow, its the API calls to weheartit.com. The IO time can be a pain if you have slow internet, nothing I can fix on my side. v0.2.1 - Implement save feature, lets users save images locally. Disclaimer Since this makeshift API client relies on the websites elements to remain unchanged, expect this package to break easily someday. useragent will be supported soon. This package, code or software is made for educational purposes and does not intend to break any ToS of weheartit.com. The creator/maintainer of this package will not be responsible for any actions done using the code. Use with your own caution and volition.","title":"Home"},{"location":"#weheartpy","text":"A fast, reliable API client for WeHeartIt.","title":"weheartpy"},{"location":"#description","text":"weheartpy is an unofficial API client for weheartit WeHeartIt does not have an API. So I have to make use of BeautifulSoup and requests to do my job. The speed is optimal, it has a limitation on number of results you can retreive through one search but its functional.","title":"Description"},{"location":"#requirements","text":"requires Python 10.* or above. read the requirements here you can easily install the packages using pip","title":"Requirements"},{"location":"#installation","text":"pip install weheartpy or pip install git+https://github.com/aswinnnn/weheartpy.git","title":"Installation"},{"location":"#features","text":"with weheartpy, you can search for: - posts aka entries - collections (including images inside them) - users - popular entries I'm adding more functionalities and utilities later on, but this is all we got for now.","title":"Features"},{"location":"#usage","text":"this is the most basic usage of the weheartpy module. # import the main class from weheartpy import WeHeartIt whi = WeHeartIt () # create an instance of WeHeartIt entries = whi . popular () # returns a list of recent popular images from homepage. for entry in entries : print ( entry . image , entry . views , entry . creator . username ) # view the entry's contents print ( entry . hearts , entry . title ) entry . save ( \"\\images\\cool_pic_from_weheartit.jpeg\" ) # save the image from the post locally. parameters - None returns - List[ Entry ] a list of Entry objects which help you access the entries easier. errors - ConnectionError","title":"Usage"},{"location":"#posts-entries","text":"search for entries. entries = whi . search_entries ( \"mean girls\" , sort = \"most_popular\" ) # returns a list of entries relevant to your query. for entry in entries : print ( entry . username , entry . image , entry . url ) parameters - query - your search query returns - List[ Entry ] a list of Entry objects which help you access the entries easier. errors - ConnectionError","title":"Posts / Entries"},{"location":"#collections","text":"# return a list of `Collection` objects resulting from the query. from weheartpy import WeHeartIt whi = WeHeartIt () cocs = whi . search_collections ( \"anime pfp\" ) for c in cocs : print ( c . title , c . link ) collection = c . get_full_collection () print ( collection . images , collection . description ) # save the images from a collection to a folder: collection . save ( \"\\collection \\\" ) # images will be saved as \"collection0.jpeg\", \"collection1.jpeg\", etc. parameters - query aka the search term returns - List[ Collection ] Check out the documentation to see what else you can do with Collection objects. errors - NoCollectionsFound","title":"Collections"},{"location":"#documentation","text":"check out the documentation for more usages. If you'd like to add something or fix mistakes, feel free to open an issue or a pull request.","title":"Documentation"},{"location":"#updates","text":"v0.2.3 - using user-agent has been made default. Fixed major bug in search_entries so you might wanna update to this version to use that correctly. v0.2.2 - Big update, the library uses weheartit's natural API to bring Entry data. this features a whole new ton of information you can use from entries such as a views, hearts, tags, titles and creation dates. It also includes a .creator attribute which is a User object of the creator of the post. If you notice anything slow, its the API calls to weheartit.com. The IO time can be a pain if you have slow internet, nothing I can fix on my side. v0.2.1 - Implement save feature, lets users save images locally.","title":"Updates"},{"location":"#disclaimer","text":"Since this makeshift API client relies on the websites elements to remain unchanged, expect this package to break easily someday. useragent will be supported soon. This package, code or software is made for educational purposes and does not intend to break any ToS of weheartit.com. The creator/maintainer of this package will not be responsible for any actions done using the code. Use with your own caution and volition.","title":"Disclaimer"},{"location":"CODE_OF_CONDUCT/","text":"Contributor Covenant Code of Conduct Our Pledge We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community. Our Standards Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community Examples of unacceptable behavior include: The use of sexualized language or imagery, and sexual attention or advances of any kind Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or email address, without their explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Enforcement Responsibilities Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate. Scope This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at aswinsnair@protonmail.com. All complaints will be reviewed and investigated promptly and fairly. All community leaders are obligated to respect the privacy and security of the reporter of any incident. Enforcement Guidelines Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct: 1. Correction Community Impact : Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence : A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested. 2. Warning Community Impact : A violation through a single incident or series of actions. Consequence : A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban. 3. Temporary Ban Community Impact : A serious violation of community standards, including sustained inappropriate behavior. Consequence : A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban. 4. Permanent Ban Community Impact : Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence : A permanent ban from any sort of public interaction within the community. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html. Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder . For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.","title":"Code Of Conduct"},{"location":"CODE_OF_CONDUCT/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"CODE_OF_CONDUCT/#our-pledge","text":"We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.","title":"Our Pledge"},{"location":"CODE_OF_CONDUCT/#our-standards","text":"Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community Examples of unacceptable behavior include: The use of sexualized language or imagery, and sexual attention or advances of any kind Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or email address, without their explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"CODE_OF_CONDUCT/#enforcement-responsibilities","text":"Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.","title":"Enforcement Responsibilities"},{"location":"CODE_OF_CONDUCT/#scope","text":"This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.","title":"Scope"},{"location":"CODE_OF_CONDUCT/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at aswinsnair@protonmail.com. All complaints will be reviewed and investigated promptly and fairly. All community leaders are obligated to respect the privacy and security of the reporter of any incident.","title":"Enforcement"},{"location":"CODE_OF_CONDUCT/#enforcement-guidelines","text":"Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:","title":"Enforcement Guidelines"},{"location":"CODE_OF_CONDUCT/#1-correction","text":"Community Impact : Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence : A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.","title":"1. Correction"},{"location":"CODE_OF_CONDUCT/#2-warning","text":"Community Impact : A violation through a single incident or series of actions. Consequence : A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.","title":"2. Warning"},{"location":"CODE_OF_CONDUCT/#3-temporary-ban","text":"Community Impact : A serious violation of community standards, including sustained inappropriate behavior. Consequence : A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.","title":"3. Temporary Ban"},{"location":"CODE_OF_CONDUCT/#4-permanent-ban","text":"Community Impact : Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence : A permanent ban from any sort of public interaction within the community.","title":"4. Permanent Ban"},{"location":"CODE_OF_CONDUCT/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html. Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder . For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.","title":"Attribution"},{"location":"CONTRIBUTING/","text":"How to contribute open a pull request! open an issue! Guidelines for pull request Please be detailed when opening your pull request! Like a nice explanation of your contribution a list of things you changed/created a list of reasons why you did what you did this isnt neccessary but certainly helps a lot when reviewing. Guidelines for issues Open an issue about anything! Im happy to an answer and close them.","title":"Contributing"},{"location":"CONTRIBUTING/#how-to-contribute","text":"open a pull request! open an issue!","title":"How to contribute"},{"location":"CONTRIBUTING/#guidelines-for-pull-request","text":"Please be detailed when opening your pull request! Like a nice explanation of your contribution a list of things you changed/created a list of reasons why you did what you did this isnt neccessary but certainly helps a lot when reviewing.","title":"Guidelines for pull request"},{"location":"CONTRIBUTING/#guidelines-for-issues","text":"Open an issue about anything! Im happy to an answer and close them.","title":"Guidelines for issues"},{"location":"reference/weheartpy/","text":"Module weheartpy None None View Source # __init__.py from .weheartpy import WeHeartIt import weheartpy Sub-modules weheartpy.handler weheartpy.models weheartpy.weheartpy Variables weheartpy","title":"Index"},{"location":"reference/weheartpy/#module-weheartpy","text":"None None View Source # __init__.py from .weheartpy import WeHeartIt import weheartpy","title":"Module weheartpy"},{"location":"reference/weheartpy/#sub-modules","text":"weheartpy.handler weheartpy.models weheartpy.weheartpy","title":"Sub-modules"},{"location":"reference/weheartpy/#variables","text":"weheartpy","title":"Variables"},{"location":"reference/weheartpy/handler/","text":"Module weheartpy.handler None None View Source # Error Handler for whi class Error (): ''' Base class where errors originate from. ''' pass class NoPostsFound ( Error ): ''' Raised when no posts are returned from a search result. ''' pass class NoCollectionsFound ( Error ): ''' Raised when no collections are returned from a search result. ''' pass class ConnectionError ( Error ): ''' Raised when the client cannot connect to weheartit.com ''' pass class NoUsersFound ( Error ): ''' Raised when a search result returns no users. ''' pass Classes ConnectionError class ConnectionError ( / , * args , ** kwargs ) View Source class ConnectionError ( Error ): ''' Raised when the client cannot connect to weheartit.com ''' pass Ancestors (in MRO) weheartpy.handler.Error Error class Error ( / , * args , ** kwargs ) View Source class Error (): ''' Base class where errors originate from. ''' pass Descendants weheartpy.handler.NoPostsFound weheartpy.handler.NoCollectionsFound weheartpy.handler.ConnectionError weheartpy.handler.NoUsersFound NoCollectionsFound class NoCollectionsFound ( / , * args , ** kwargs ) View Source class NoCollectionsFound ( Error ): ''' Raised when no collections are returned from a search result. ''' pass Ancestors (in MRO) weheartpy.handler.Error NoPostsFound class NoPostsFound ( / , * args , ** kwargs ) View Source class NoPostsFound ( Error ): ''' Raised when no posts are returned from a search result. ''' pass Ancestors (in MRO) weheartpy.handler.Error NoUsersFound class NoUsersFound ( / , * args , ** kwargs ) View Source class NoUsersFound ( Error ): ''' Raised when a search result returns no users. ''' pass Ancestors (in MRO) weheartpy.handler.Error","title":"Handler"},{"location":"reference/weheartpy/handler/#module-weheartpyhandler","text":"None None View Source # Error Handler for whi class Error (): ''' Base class where errors originate from. ''' pass class NoPostsFound ( Error ): ''' Raised when no posts are returned from a search result. ''' pass class NoCollectionsFound ( Error ): ''' Raised when no collections are returned from a search result. ''' pass class ConnectionError ( Error ): ''' Raised when the client cannot connect to weheartit.com ''' pass class NoUsersFound ( Error ): ''' Raised when a search result returns no users. ''' pass","title":"Module weheartpy.handler"},{"location":"reference/weheartpy/handler/#classes","text":"","title":"Classes"},{"location":"reference/weheartpy/handler/#connectionerror","text":"class ConnectionError ( / , * args , ** kwargs ) View Source class ConnectionError ( Error ): ''' Raised when the client cannot connect to weheartit.com ''' pass","title":"ConnectionError"},{"location":"reference/weheartpy/handler/#ancestors-in-mro","text":"weheartpy.handler.Error","title":"Ancestors (in MRO)"},{"location":"reference/weheartpy/handler/#error","text":"class Error ( / , * args , ** kwargs ) View Source class Error (): ''' Base class where errors originate from. ''' pass","title":"Error"},{"location":"reference/weheartpy/handler/#descendants","text":"weheartpy.handler.NoPostsFound weheartpy.handler.NoCollectionsFound weheartpy.handler.ConnectionError weheartpy.handler.NoUsersFound","title":"Descendants"},{"location":"reference/weheartpy/handler/#nocollectionsfound","text":"class NoCollectionsFound ( / , * args , ** kwargs ) View Source class NoCollectionsFound ( Error ): ''' Raised when no collections are returned from a search result. ''' pass","title":"NoCollectionsFound"},{"location":"reference/weheartpy/handler/#ancestors-in-mro_1","text":"weheartpy.handler.Error","title":"Ancestors (in MRO)"},{"location":"reference/weheartpy/handler/#nopostsfound","text":"class NoPostsFound ( / , * args , ** kwargs ) View Source class NoPostsFound ( Error ): ''' Raised when no posts are returned from a search result. ''' pass","title":"NoPostsFound"},{"location":"reference/weheartpy/handler/#ancestors-in-mro_2","text":"weheartpy.handler.Error","title":"Ancestors (in MRO)"},{"location":"reference/weheartpy/handler/#nousersfound","text":"class NoUsersFound ( / , * args , ** kwargs ) View Source class NoUsersFound ( Error ): ''' Raised when a search result returns no users. ''' pass","title":"NoUsersFound"},{"location":"reference/weheartpy/handler/#ancestors-in-mro_3","text":"weheartpy.handler.Error","title":"Ancestors (in MRO)"},{"location":"reference/weheartpy/models/","text":"Module weheartpy.models None None View Source # The objects through which the results will be returned. import requests from bs4 import BeautifulSoup as bs class Entry (): ''' Base class of a weheartit.com \"post\" or entry, as they like to call it. - attributes: - - id: `int` : entry id - - username: `str`: username of creator of the post. - - url: `str`: url of the post. - - image: `str`: a `.jpg` link to the image of the post. this class is not meant to be modified or instantiated by you, rather the API. you will be utilizing this object to deal with the results you get from `popular()` or `search_entries()` ''' def __init__ ( self , id : int , username : str , entry : str , image : str , title : str = None ) -> None : self . id = id self . username = username self . url = \"https://weheartit.com\" + entry self . image = image self . title = title def __repr__ ( self ) -> str : return f \"Entry(id= { self . id } , username= { self . username } , url= { self . url } , image= { self . image } , title= { self . title } )\" def __eq__ ( self , __o : object ) -> bool : return self . url == __o . url def __ne__ ( self , __o : object ) -> bool : return self . url != __o . url class Collection (): ''' The base `Collection` object through which you can access collections - attributes - - username: `str`: username of the collection creator - - link: `str`: link to the collection - - title: `str`: title of the collection - methods - - `get_full_collection`: returns the `Collection` object with (first page) images inside the collection and its description. ''' def __init__ ( self , username : str , title : str , link : str ) -> None : self . username = username self . title = title self . link = link self . description = None self . images = None def __repr__ ( self ) -> str : return f \"Collection(username= { self . username } , title= { self . title } , link= { self . link } ), description= { self . description } , images= { self . images } \" def __eq__ ( self , __o : object ) -> bool : return self . link . casefold () == __o . link . casefold () def __ne__ ( self , __o : object ) -> bool : return self . link . casefold () != __o . link . casefold () def get_full_collection ( self ): ''' return the `Collection` with the (first page) images inside and its description. ``` cocs = whi.search_collections(\"egirl\") for collection in cocs: print(collection.description, collection.images) ``` ''' res = requests . get ( self . link ) res = bs ( res . text , features = \"lxml\" ) desc = res . find_all ( 'p' , { 'class' : 'text-gray' }) desc = \"\" . join ([ d . text for d in desc ]) entries = [] entrier = res . find_all ( 'a' , { 'class' : 'js-entry-detail-link js-blc js-blc-t-entry' }) for e in entrier : entries . append ( \"https://data.whicdn.com\" + ( e [ 'href' ]) . replace ( \"entry\" , \"images\" ) + \"/original.jpg\" ) self . images = entries self . description = desc return self class User (): ''' Base class for one weheartit user. - attributes - - username: `str`: username of the user. - - name: `str`: name of the user. - - avatar: link to the avatar of the user. ''' def __init__ ( self , username : str , name : str , avatar : str ) -> None : self . username = username self . name = name self . avatar = avatar def __repr__ ( self ) -> str : return f \"User(username= { self . username } , name= { self . name } , avatar= { self . avatar } )\" def __eq__ ( self , __o : object ) -> bool : return self . username . casefold () == __o . username . casefold () def __ne__ ( self , __o : object ) -> bool : return self . username . casefold () != __o . username . casefold () Classes Collection class Collection ( username : str , title : str , link : str ) View Source class Collection () : ' '' The base `Collection` object through which you can access collections - attributes - - username: `str`: username of the collection creator - - link: `str`: link to the collection - - title: `str`: title of the collection - methods - - `get_full_collection`: returns the `Collection` object with (first page) images inside the collection and its description. '' ' def __init__ ( self , username : str , title : str , link : str ) -> None : self . username = username self . title = title self . link = link self . description = None self . images = None def __repr__ ( self ) -> str : return f \"Collection(username={self.username}, title={self.title}, link={self.link}), description={self.description}, images={self.images}\" def __eq__ ( self , __o : object ) -> bool : return self . link . casefold () == __o . link . casefold () def __ne__ ( self , __o : object ) -> bool : return self . link . casefold () != __o . link . casefold () def get_full_collection ( self ) : ' '' return the `Collection` with the (first page) images inside and its description. ``` cocs = whi.search_collections(\"egirl\") for collection in cocs: print(collection.description, collection.images) ``` '' ' res = requests . get ( self . link ) res = bs ( res . text , features = \"lxml\" ) desc = res . find_all ( 'p' , { 'class' : 'text-gray' } ) desc = \"\" . join ( [ d . text for d in desc ] ) entries = [] entrier = res . find_all ( 'a' , { 'class' : 'js-entry-detail-link js-blc js-blc-t-entry' } ) for e in entrier : entries . append ( \"https://data.whicdn.com\" + ( e [ 'href' ] ). replace ( \"entry\" , \"images\" ) + \"/original.jpg\" ) self . images = entries self . description = desc return self Methods get_full_collection def get_full_collection ( self ) return the Collection with the (first page) images inside and its description. cocs = whi . search_collections ( \" egirl \" ) for collection in cocs : print ( collection . description , collection . images ) View Source def get_full_collection ( self ) : ' '' return the `Collection` with the (first page) images inside and its description. ``` cocs = whi.search_collections(\"egirl\") for collection in cocs: print(collection.description, collection.images) ``` '' ' res = requests . get ( self . link ) res = bs ( res . text , features = \"lxml\" ) desc = res . find_all ( 'p' , { 'class' : 'text-gray' } ) desc = \"\" . join ( [ d . text for d in desc ] ) entries = [] entrier = res . find_all ( 'a' , { 'class' : 'js-entry-detail-link js-blc js-blc-t-entry' } ) for e in entrier : entries . append ( \"https://data.whicdn.com\" + ( e [ 'href' ] ). replace ( \"entry\" , \"images\" ) + \"/original.jpg\" ) self . images = entries self . description = desc return self Entry class Entry ( id : int , username : str , entry : str , image : str , title : str = None ) View Source class Entry () : ' '' Base class of a weheartit.com \"post\" or entry, as they like to call it. - attributes: - - id: `int` : entry id - - username: `str`: username of creator of the post. - - url: `str`: url of the post. - - image: `str`: a `.jpg` link to the image of the post. this class is not meant to be modified or instantiated by you, rather the API. you will be utilizing this object to deal with the results you get from `popular()` or `search_entries()` '' ' def __init__ ( self , id : int , username : str , entry : str , image : str , title : str = None ) -> None : self . id = id self . username = username self . url = \"https://weheartit.com\" + entry self . image = image self . title = title def __repr__ ( self ) -> str : return f \"Entry(id={self.id}, username={self.username}, url={self.url}, image={self.image}, title={self.title})\" def __eq__ ( self , __o : object ) -> bool : return self . url == __o . url def __ne__ ( self , __o : object ) -> bool : return self . url != __o . url User class User ( username : str , name : str , avatar : str ) View Source class User () : ' '' Base class for one weheartit user. - attributes - - username: `str`: username of the user. - - name: `str`: name of the user. - - avatar: link to the avatar of the user. '' ' def __init__ ( self , username : str , name : str , avatar : str ) -> None : self . username = username self . name = name self . avatar = avatar def __repr__ ( self ) -> str : return f \"User(username={self.username}, name={self.name}, avatar={self.avatar})\" def __eq__ ( self , __o : object ) -> bool : return self . username . casefold () == __o . username . casefold () def __ne__ ( self , __o : object ) -> bool : return self . username . casefold () != __o . username . casefold ()","title":"Models"},{"location":"reference/weheartpy/models/#module-weheartpymodels","text":"None None View Source # The objects through which the results will be returned. import requests from bs4 import BeautifulSoup as bs class Entry (): ''' Base class of a weheartit.com \"post\" or entry, as they like to call it. - attributes: - - id: `int` : entry id - - username: `str`: username of creator of the post. - - url: `str`: url of the post. - - image: `str`: a `.jpg` link to the image of the post. this class is not meant to be modified or instantiated by you, rather the API. you will be utilizing this object to deal with the results you get from `popular()` or `search_entries()` ''' def __init__ ( self , id : int , username : str , entry : str , image : str , title : str = None ) -> None : self . id = id self . username = username self . url = \"https://weheartit.com\" + entry self . image = image self . title = title def __repr__ ( self ) -> str : return f \"Entry(id= { self . id } , username= { self . username } , url= { self . url } , image= { self . image } , title= { self . title } )\" def __eq__ ( self , __o : object ) -> bool : return self . url == __o . url def __ne__ ( self , __o : object ) -> bool : return self . url != __o . url class Collection (): ''' The base `Collection` object through which you can access collections - attributes - - username: `str`: username of the collection creator - - link: `str`: link to the collection - - title: `str`: title of the collection - methods - - `get_full_collection`: returns the `Collection` object with (first page) images inside the collection and its description. ''' def __init__ ( self , username : str , title : str , link : str ) -> None : self . username = username self . title = title self . link = link self . description = None self . images = None def __repr__ ( self ) -> str : return f \"Collection(username= { self . username } , title= { self . title } , link= { self . link } ), description= { self . description } , images= { self . images } \" def __eq__ ( self , __o : object ) -> bool : return self . link . casefold () == __o . link . casefold () def __ne__ ( self , __o : object ) -> bool : return self . link . casefold () != __o . link . casefold () def get_full_collection ( self ): ''' return the `Collection` with the (first page) images inside and its description. ``` cocs = whi.search_collections(\"egirl\") for collection in cocs: print(collection.description, collection.images) ``` ''' res = requests . get ( self . link ) res = bs ( res . text , features = \"lxml\" ) desc = res . find_all ( 'p' , { 'class' : 'text-gray' }) desc = \"\" . join ([ d . text for d in desc ]) entries = [] entrier = res . find_all ( 'a' , { 'class' : 'js-entry-detail-link js-blc js-blc-t-entry' }) for e in entrier : entries . append ( \"https://data.whicdn.com\" + ( e [ 'href' ]) . replace ( \"entry\" , \"images\" ) + \"/original.jpg\" ) self . images = entries self . description = desc return self class User (): ''' Base class for one weheartit user. - attributes - - username: `str`: username of the user. - - name: `str`: name of the user. - - avatar: link to the avatar of the user. ''' def __init__ ( self , username : str , name : str , avatar : str ) -> None : self . username = username self . name = name self . avatar = avatar def __repr__ ( self ) -> str : return f \"User(username= { self . username } , name= { self . name } , avatar= { self . avatar } )\" def __eq__ ( self , __o : object ) -> bool : return self . username . casefold () == __o . username . casefold () def __ne__ ( self , __o : object ) -> bool : return self . username . casefold () != __o . username . casefold ()","title":"Module weheartpy.models"},{"location":"reference/weheartpy/models/#classes","text":"","title":"Classes"},{"location":"reference/weheartpy/models/#collection","text":"class Collection ( username : str , title : str , link : str ) View Source class Collection () : ' '' The base `Collection` object through which you can access collections - attributes - - username: `str`: username of the collection creator - - link: `str`: link to the collection - - title: `str`: title of the collection - methods - - `get_full_collection`: returns the `Collection` object with (first page) images inside the collection and its description. '' ' def __init__ ( self , username : str , title : str , link : str ) -> None : self . username = username self . title = title self . link = link self . description = None self . images = None def __repr__ ( self ) -> str : return f \"Collection(username={self.username}, title={self.title}, link={self.link}), description={self.description}, images={self.images}\" def __eq__ ( self , __o : object ) -> bool : return self . link . casefold () == __o . link . casefold () def __ne__ ( self , __o : object ) -> bool : return self . link . casefold () != __o . link . casefold () def get_full_collection ( self ) : ' '' return the `Collection` with the (first page) images inside and its description. ``` cocs = whi.search_collections(\"egirl\") for collection in cocs: print(collection.description, collection.images) ``` '' ' res = requests . get ( self . link ) res = bs ( res . text , features = \"lxml\" ) desc = res . find_all ( 'p' , { 'class' : 'text-gray' } ) desc = \"\" . join ( [ d . text for d in desc ] ) entries = [] entrier = res . find_all ( 'a' , { 'class' : 'js-entry-detail-link js-blc js-blc-t-entry' } ) for e in entrier : entries . append ( \"https://data.whicdn.com\" + ( e [ 'href' ] ). replace ( \"entry\" , \"images\" ) + \"/original.jpg\" ) self . images = entries self . description = desc return self","title":"Collection"},{"location":"reference/weheartpy/models/#methods","text":"","title":"Methods"},{"location":"reference/weheartpy/models/#get_full_collection","text":"def get_full_collection ( self ) return the Collection with the (first page) images inside and its description. cocs = whi . search_collections ( \" egirl \" ) for collection in cocs : print ( collection . description , collection . images ) View Source def get_full_collection ( self ) : ' '' return the `Collection` with the (first page) images inside and its description. ``` cocs = whi.search_collections(\"egirl\") for collection in cocs: print(collection.description, collection.images) ``` '' ' res = requests . get ( self . link ) res = bs ( res . text , features = \"lxml\" ) desc = res . find_all ( 'p' , { 'class' : 'text-gray' } ) desc = \"\" . join ( [ d . text for d in desc ] ) entries = [] entrier = res . find_all ( 'a' , { 'class' : 'js-entry-detail-link js-blc js-blc-t-entry' } ) for e in entrier : entries . append ( \"https://data.whicdn.com\" + ( e [ 'href' ] ). replace ( \"entry\" , \"images\" ) + \"/original.jpg\" ) self . images = entries self . description = desc return self","title":"get_full_collection"},{"location":"reference/weheartpy/models/#entry","text":"class Entry ( id : int , username : str , entry : str , image : str , title : str = None ) View Source class Entry () : ' '' Base class of a weheartit.com \"post\" or entry, as they like to call it. - attributes: - - id: `int` : entry id - - username: `str`: username of creator of the post. - - url: `str`: url of the post. - - image: `str`: a `.jpg` link to the image of the post. this class is not meant to be modified or instantiated by you, rather the API. you will be utilizing this object to deal with the results you get from `popular()` or `search_entries()` '' ' def __init__ ( self , id : int , username : str , entry : str , image : str , title : str = None ) -> None : self . id = id self . username = username self . url = \"https://weheartit.com\" + entry self . image = image self . title = title def __repr__ ( self ) -> str : return f \"Entry(id={self.id}, username={self.username}, url={self.url}, image={self.image}, title={self.title})\" def __eq__ ( self , __o : object ) -> bool : return self . url == __o . url def __ne__ ( self , __o : object ) -> bool : return self . url != __o . url","title":"Entry"},{"location":"reference/weheartpy/models/#user","text":"class User ( username : str , name : str , avatar : str ) View Source class User () : ' '' Base class for one weheartit user. - attributes - - username: `str`: username of the user. - - name: `str`: name of the user. - - avatar: link to the avatar of the user. '' ' def __init__ ( self , username : str , name : str , avatar : str ) -> None : self . username = username self . name = name self . avatar = avatar def __repr__ ( self ) -> str : return f \"User(username={self.username}, name={self.name}, avatar={self.avatar})\" def __eq__ ( self , __o : object ) -> bool : return self . username . casefold () == __o . username . casefold () def __ne__ ( self , __o : object ) -> bool : return self . username . casefold () != __o . username . casefold ()","title":"User"},{"location":"reference/weheartpy/weheartpy/","text":"Module weheartpy.weheartpy None None View Source import requests from bs4 import BeautifulSoup as bs from .handler import Error , NoCollectionsFound , NoPostsFound , ConnectionError , NoUsersFound from .models import Entry , Collection , User class WeHeartIt (): ''' the WeHeartIt class. eg. instantiating the class: `` whi = WeHeartIt() popular_posts = whi.popular() `` ''' def __init__ ( self ) -> None : err = requests . get ( \"https://weheartit.com\" ) try : err . raise_for_status () except requests . HTTPError : raise ConnectionError ( f \"The API cannot connect to weheartit.com \\n REASON: { err . reason } \\n help: Try checking your network connection.\" ) self . status = err . status_code self . url = err . url def popular ( self ) -> list [ Entry ]: ''' return a list of ``Entry`` objects of the popular images. - - ``` whi = WeHeartIt() entries = whi.popular() for entry in entries: print(entry.id) print(entry.username) print(entry.image) print(entry.url) ``` ''' res = requests . get ( \"https://weheartit.com\" ) res = bs ( res . text ) images = res . find_all ( 'a' , { 'class' : 'entry js-blc js-blc-t-heart btn-heart btn btn-heart-circle js-heart-button' }) entries = [] for img in images : image = f \"https://data.whicdn.com/images/ { img [ 'data-entry-id' ] } /original.jpg\" entry = Entry ( id = int ( img [ 'data-entry-id' ]), username = img [ 'data-hearter-username' ], entry = img [ 'href' ], image = image ) entries . append ( entry ) if len ( entries ) == 0 : raise NoPostsFound ( 'No posts were found. This might be a useragent or a website problem. Are you sure weheartit.com still has a popular images section? \\n SOURCE: WeHeartIt.popular | match case \"low\" \\n ' ) return return entries def search_collections ( self , query : str ) -> list [ Collection ]: ''' return a list of ``Collection`` objects resulting from the query. ``` from weheartpy import WeHeartIt whi = WeHeartIt() cocs = whi.search_collections(\"anime pfp\") for c in cocs: print(c.title, c.link) ``` ''' res = requests . get ( f \"https://weheartit.com/search/collections?query= { query } &sort=most_recent\" ) find = bs ( res . text ) atags = find . find_all ( 'a' , { 'class' : 'js-blc js-blc-t-collection collection-name text-overflow-parent' }) collections = [] for a in atags : link = a [ 'href' ] pop = bs ( str ( a )) title = pop . find_all ( 'span' , { 'class' : 'text-primary' }) title = ( title [ 0 ]) . text username = pop . find_all ( 'small' ) username = ((( username [ 0 ]) . text ) . replace ( 'by @' , '' )) . strip () collections . append ( Collection ( username = username , title = title , link = link )) if len ( collections ) == 0 : raise NoCollectionsFound ( \"the API could not find any collections with that query! Try with something else.\" ) return return collections def search_entries ( self , query : str , sort : str = None ) -> list [ Entry ]: ''' returns a list of ``Entry`` objects according to your search query. + params + + sort: `str`: sort the type of entries. Only one option `most_popular`. When left empty the API will go for most recent instead. ``` whi = WeHeartIt() entries = whi.search_entries(\"mean girls\", sort=\"most_popular\") for entry in entries: print(entry.image, entry.url, entry.username) ``` ''' url = f \"https://weheartit.com/search/entries?query= { query } \" if sort == None else f \"https://weheartit.com/search/entries?query= { query } &sort=most_popular\" res = requests . get () find = bs ( res . text , features = \"lxml\" ) entries = find . find_all ( 'a' , { 'class' : 'js-entry-detail-link js-blc js-blc-t-entry' }) usernames = find . find_all ( 'a' , { 'class' : 'entry js-blc js-blc-t-heart btn-heart btn btn-heart-circle js-heart-button' }) rentries = [] try : for e , u in zip ( entries , usernames ): image = \"https://weheartit.com/images/\" + u [ 'data-entry-id' ] + \"/original.jpg\" id = int ( u [ 'data-entry-id' ]) entry = Entry ( id = id , title = e [ 'title' ], username = u [ 'data-hearter-username' ], entry = e [ 'href' ], image = image ) rentries . append ( entry ) except : raise NoPostsFound ( \"Could not find any entries related to that search query. Try again with a different one or check your search query.\" ); return return rentries def search_users ( self , query : str ) -> list [ User ]: ''' returns a list of ``User``s according to search query. The number of users is limited to top 40 users thats relevant to your search query. The ``User`` object will return users usernames, names and links to their avatars. + params + + query: `str`: search query that you'd like to search. ``` whi = WeHeartIt() hearters = whi.search_users(\"sophie\") for user in hearters: print(user.name, user.username, user.avatar) ``` ''' res = requests . get ( f \"https://weheartit.com/search/users?query= { query } \" ) find = bs ( res . text , features = \"lxml\" ) entries = find . find_all ( 'span' , { 'class' : 'text-overflow' }) users = [] for e in entries : e = bs ( str ( e ), features = \"lxml\" ) name = ( e . find ( 'span' , { 'class' : 'text-big' })) . text . strip () username = ( e . find ( 'small' )) . text [ 1 :] avatar = find . find ( 'img' , { 'alt' : f ' { name } ' , 'class' : 'avatar' }) avatar = avatar [ 'src' ] users . append ( User ( username = username , name = name , avatar = avatar )) if len ( users ) == 0 : raise NoUsersFound ( \"weheartpy could not find any users related to that search query. Try again with a different one or check your query. \\n \" ); return return users Classes WeHeartIt class WeHeartIt ( ) View Source class WeHeartIt () : ' '' the WeHeartIt class. eg. instantiating the class: `` whi = WeHeartIt() popular_posts = whi.popular() `` '' ' def __init__ ( self ) -> None : err = requests . get ( \"https://weheartit.com\" ) try : err . raise_for_status () except requests . HTTPError : raise ConnectionError ( f \"The API cannot connect to weheartit.com \\n REASON: {err.reason} \\n help: Try checking your network connection.\" ) self . status = err . status_code self . url = err . url def popular ( self ) -> list [ Entry ] : ' '' return a list of ``Entry`` objects of the popular images. - - ``` whi = WeHeartIt() entries = whi.popular() for entry in entries: print(entry.id) print(entry.username) print(entry.image) print(entry.url) ``` '' ' res = requests . get ( \"https://weheartit.com\" ) res = bs ( res . text ) images = res . find_all ( 'a' , { 'class' : 'entry js-blc js-blc-t-heart btn-heart btn btn-heart-circle js-heart-button' } ) entries = [] for img in images : image = f \"https://data.whicdn.com/images/{img['data-entry-id']}/original.jpg\" entry = Entry ( id = int ( img [ 'data-entry-id' ] ), username = img [ 'data-hearter-username' ] , entry = img [ 'href' ] , image = image ) entries . append ( entry ) if len ( entries ) == 0 : raise NoPostsFound ( 'No posts were found. This might be a useragent or a website problem. Are you sure weheartit.com still has a popular images section? \\n SOURCE: WeHeartIt.popular | match case \"low\" \\n ' ) return return entries def search_collections ( self , query : str ) -> list [ Collection ] : ' '' return a list of ``Collection`` objects resulting from the query. ``` from weheartpy import WeHeartIt whi = WeHeartIt() cocs = whi.search_collections(\"anime pfp\") for c in cocs: print(c.title, c.link) ``` '' ' res = requests . get ( f \"https://weheartit.com/search/collections?query={query}&sort=most_recent\" ) find = bs ( res . text ) atags = find . find_all ( 'a' , { 'class' : 'js-blc js-blc-t-collection collection-name text-overflow-parent' } ) collections = [] for a in atags : link = a [ 'href' ] pop = bs ( str ( a )) title = pop . find_all ( 'span' , { 'class' : 'text-primary' } ) title = ( title [ 0 ] ). text username = pop . find_all ( 'small' ) username = ((( username [ 0 ] ). text ). replace ( 'by @' , '' )). strip () collections . append ( Collection ( username = username , title = title , link = link )) if len ( collections ) == 0 : raise NoCollectionsFound ( \"the API could not find any collections with that query! Try with something else.\" ) return return collections def search_entries ( self , query : str , sort : str = None ) -> list [ Entry ] : ' '' returns a list of ``Entry`` objects according to your search query. + params + + sort: `str`: sort the type of entries. Only one option `most_popular`. When left empty the API will go for most recent instead. ``` whi = WeHeartIt() entries = whi.search_entries(\"mean girls\", sort=\"most_popular\") for entry in entries: print(entry.image, entry.url, entry.username) ``` '' ' url = f \"https://weheartit.com/search/entries?query={query}\" if sort == None else f \"https://weheartit.com/search/entries?query={query}&sort=most_popular\" res = requests . get () find = bs ( res . text , features = \"lxml\" ) entries = find . find_all ( 'a' , { 'class' : 'js-entry-detail-link js-blc js-blc-t-entry' } ) usernames = find . find_all ( 'a' , { 'class' : 'entry js-blc js-blc-t-heart btn-heart btn btn-heart-circle js-heart-button' } ) rentries = [] try : for e , u in zip ( entries , usernames ) : image = \"https://weheartit.com/images/\" + u [ 'data-entry-id' ] + \"/original.jpg\" id = int ( u [ 'data-entry-id' ] ) entry = Entry ( id = id , title = e [ 'title' ] , username = u [ 'data-hearter-username' ] , entry = e [ 'href' ] , image = image ) rentries . append ( entry ) except : raise NoPostsFound ( \"Could not find any entries related to that search query. Try again with a different one or check your search query.\" ); return return rentries def search_users ( self , query : str ) -> list [ User ] : ' '' returns a list of ``User``s according to search query. The number of users is limited to top 40 users thats relevant to your search query. The ``User`` object will return users usernames, names and links to their avatars. + params + + query: `str`: search query that you' d like to search . ` `` whi = WeHeartIt() hearters = whi.search_users(\"sophie\") for user in hearters: print(user.name, user.username, user.avatar) `` ` ' '' res = requests.get(f\"https://weheartit.com/search/users?query={query}\") find = bs(res.text, features=\"lxml\") entries = find.find_all(' span ', {' class ': ' text - overflow '}) users = [] for e in entries: e = bs(str(e), features=\"lxml\") name = (e.find(' span ', {' class ': ' text - big '})).text.strip() username = (e.find(' small ')).text[1:] avatar = find.find(' img ', {' alt ': f' { name } ', ' class ': ' avatar '}) avatar = avatar[' src '] users.append(User(username=username, name=name, avatar=avatar)) if len(users) == 0: raise NoUsersFound(\"weheartpy could not find any users related to that search query. Try again with a different one or check your query. \\n \"); return return users Methods popular def popular ( self ) -> list [ weheartpy . models . Entry ] return a list of Entry objects of the popular images. - whi = WeHeartIt () entries = whi . popular () for entry in entries : print ( entry . id ) print ( entry . username ) print ( entry . image ) print ( entry . url ) View Source def popular ( self ) -> list [ Entry ] : ' '' return a list of ``Entry`` objects of the popular images. - - ``` whi = WeHeartIt() entries = whi.popular() for entry in entries: print(entry.id) print(entry.username) print(entry.image) print(entry.url) ``` '' ' res = requests . get ( \"https://weheartit.com\" ) res = bs ( res . text ) images = res . find_all ( 'a' , { 'class' : 'entry js-blc js-blc-t-heart btn-heart btn btn-heart-circle js-heart-button' } ) entries = [] for img in images : image = f \"https://data.whicdn.com/images/{img['data-entry-id']}/original.jpg\" entry = Entry ( id = int ( img [ 'data-entry-id' ] ), username = img [ 'data-hearter-username' ] , entry = img [ 'href' ] , image = image ) entries . append ( entry ) if len ( entries ) == 0 : raise NoPostsFound ( 'No posts were found. This might be a useragent or a website problem. Are you sure weheartit.com still has a popular images section? \\n SOURCE: WeHeartIt.popular | match case \"low\" \\n ' ) return return entries search_collections def search_collections ( self , query : str ) -> list [ weheartpy . models . Collection ] return a list of Collection objects resulting from the query. from weheartpy import WeHeartIt whi = WeHeartIt () cocs = whi . search_collections ( \"anime pfp\" ) for c in cocs : print ( c . title , c . link ) View Source def search_collections ( self , query : str ) -> list [ Collection ]: ''' return a list of ``Collection`` objects resulting from the query. ``` from weheartpy import WeHeartIt whi = WeHeartIt() cocs = whi.search_collections(\"anime pfp\") for c in cocs: print(c.title, c.link) ``` ''' res = requests . get ( f \"https://weheartit.com/search/collections?query= { query } &sort=most_recent\" ) find = bs ( res . text ) atags = find . find_all ( 'a' , { 'class' : 'js-blc js-blc-t-collection collection-name text-overflow-parent' }) collections = [] for a in atags : link = a [ 'href' ] pop = bs ( str ( a )) title = pop . find_all ( 'span' , { 'class' : 'text-primary' }) title = ( title [ 0 ]) . text username = pop . find_all ( 'small' ) username = ((( username [ 0 ]) . text ) . replace ( 'by @' , '' )) . strip () collections . append ( Collection ( username = username , title = title , link = link )) if len ( collections ) == 0 : raise NoCollectionsFound ( \"the API could not find any collections with that query! Try with something else.\" ) return return collections search_entries def search_entries ( self , query : str , sort : str = None ) -> list [ weheartpy . models . Entry ] returns a list of Entry objects according to your search query. params sort: str : sort the type of entries. Only one option most_popular . When left empty the API will go for most recent instead. whi = WeHeartIt () entries = whi . search_entries ( \" mean girls \" , sort = \" most_popular \" ) for entry in entries : print ( entry . image , entry . url , entry . username ) View Source def search_entries ( self , query : str , sort : str = None ) -> list [ Entry ] : ' '' returns a list of ``Entry`` objects according to your search query. + params + + sort: `str`: sort the type of entries. Only one option `most_popular`. When left empty the API will go for most recent instead. ``` whi = WeHeartIt() entries = whi.search_entries(\"mean girls\", sort=\"most_popular\") for entry in entries: print(entry.image, entry.url, entry.username) ``` '' ' url = f \"https://weheartit.com/search/entries?query={query}\" if sort == None else f \"https://weheartit.com/search/entries?query={query}&sort=most_popular\" res = requests . get () find = bs ( res . text , features = \"lxml\" ) entries = find . find_all ( 'a' , { 'class' : 'js-entry-detail-link js-blc js-blc-t-entry' } ) usernames = find . find_all ( 'a' , { 'class' : 'entry js-blc js-blc-t-heart btn-heart btn btn-heart-circle js-heart-button' } ) rentries = [] try : for e , u in zip ( entries , usernames ) : image = \"https://weheartit.com/images/\" + u [ 'data-entry-id' ] + \"/original.jpg\" id = int ( u [ 'data-entry-id' ] ) entry = Entry ( id = id , title = e [ 'title' ] , username = u [ 'data-hearter-username' ] , entry = e [ 'href' ] , image = image ) rentries . append ( entry ) except : raise NoPostsFound ( \"Could not find any entries related to that search query. Try again with a different one or check your search query.\" ); return return rentries search_users def search_users ( self , query : str ) -> list [ weheartpy . models . User ] returns a list of User s according to search query. The number of users is limited to top 40 users thats relevant to your search query. The User object will return users usernames, names and links to their avatars. params query: str : search query that you'd like to search. whi = WeHeartIt () hearters = whi . search_users ( \" sophie \" ) for user in hearters : print ( user . name , user . username , user . avatar ) View Source def search_users ( self , query : str ) -> list [ User ] : ' '' returns a list of ``User``s according to search query. The number of users is limited to top 40 users thats relevant to your search query. The ``User`` object will return users usernames, names and links to their avatars. + params + + query: `str`: search query that you' d like to search . ` `` whi = WeHeartIt() hearters = whi.search_users(\"sophie\") for user in hearters: print(user.name, user.username, user.avatar) `` ` ' '' res = requests.get(f\"https://weheartit.com/search/users?query={query}\") find = bs(res.text, features=\"lxml\") entries = find.find_all(' span ', {' class ': ' text - overflow '}) users = [] for e in entries: e = bs(str(e), features=\"lxml\") name = (e.find(' span ', {' class ': ' text - big '})).text.strip() username = (e.find(' small ')).text[1:] avatar = find.find(' img ', {' alt ': f' { name } ', ' class ': ' avatar '}) avatar = avatar[' src '] users.append(User(username=username, name=name, avatar=avatar)) if len(users) == 0: raise NoUsersFound(\"weheartpy could not find any users related to that search query. Try again with a different one or check your query. \\n \"); return return users","title":"Weheartpy"},{"location":"reference/weheartpy/weheartpy/#module-weheartpyweheartpy","text":"None None View Source import requests from bs4 import BeautifulSoup as bs from .handler import Error , NoCollectionsFound , NoPostsFound , ConnectionError , NoUsersFound from .models import Entry , Collection , User class WeHeartIt (): ''' the WeHeartIt class. eg. instantiating the class: `` whi = WeHeartIt() popular_posts = whi.popular() `` ''' def __init__ ( self ) -> None : err = requests . get ( \"https://weheartit.com\" ) try : err . raise_for_status () except requests . HTTPError : raise ConnectionError ( f \"The API cannot connect to weheartit.com \\n REASON: { err . reason } \\n help: Try checking your network connection.\" ) self . status = err . status_code self . url = err . url def popular ( self ) -> list [ Entry ]: ''' return a list of ``Entry`` objects of the popular images. - - ``` whi = WeHeartIt() entries = whi.popular() for entry in entries: print(entry.id) print(entry.username) print(entry.image) print(entry.url) ``` ''' res = requests . get ( \"https://weheartit.com\" ) res = bs ( res . text ) images = res . find_all ( 'a' , { 'class' : 'entry js-blc js-blc-t-heart btn-heart btn btn-heart-circle js-heart-button' }) entries = [] for img in images : image = f \"https://data.whicdn.com/images/ { img [ 'data-entry-id' ] } /original.jpg\" entry = Entry ( id = int ( img [ 'data-entry-id' ]), username = img [ 'data-hearter-username' ], entry = img [ 'href' ], image = image ) entries . append ( entry ) if len ( entries ) == 0 : raise NoPostsFound ( 'No posts were found. This might be a useragent or a website problem. Are you sure weheartit.com still has a popular images section? \\n SOURCE: WeHeartIt.popular | match case \"low\" \\n ' ) return return entries def search_collections ( self , query : str ) -> list [ Collection ]: ''' return a list of ``Collection`` objects resulting from the query. ``` from weheartpy import WeHeartIt whi = WeHeartIt() cocs = whi.search_collections(\"anime pfp\") for c in cocs: print(c.title, c.link) ``` ''' res = requests . get ( f \"https://weheartit.com/search/collections?query= { query } &sort=most_recent\" ) find = bs ( res . text ) atags = find . find_all ( 'a' , { 'class' : 'js-blc js-blc-t-collection collection-name text-overflow-parent' }) collections = [] for a in atags : link = a [ 'href' ] pop = bs ( str ( a )) title = pop . find_all ( 'span' , { 'class' : 'text-primary' }) title = ( title [ 0 ]) . text username = pop . find_all ( 'small' ) username = ((( username [ 0 ]) . text ) . replace ( 'by @' , '' )) . strip () collections . append ( Collection ( username = username , title = title , link = link )) if len ( collections ) == 0 : raise NoCollectionsFound ( \"the API could not find any collections with that query! Try with something else.\" ) return return collections def search_entries ( self , query : str , sort : str = None ) -> list [ Entry ]: ''' returns a list of ``Entry`` objects according to your search query. + params + + sort: `str`: sort the type of entries. Only one option `most_popular`. When left empty the API will go for most recent instead. ``` whi = WeHeartIt() entries = whi.search_entries(\"mean girls\", sort=\"most_popular\") for entry in entries: print(entry.image, entry.url, entry.username) ``` ''' url = f \"https://weheartit.com/search/entries?query= { query } \" if sort == None else f \"https://weheartit.com/search/entries?query= { query } &sort=most_popular\" res = requests . get () find = bs ( res . text , features = \"lxml\" ) entries = find . find_all ( 'a' , { 'class' : 'js-entry-detail-link js-blc js-blc-t-entry' }) usernames = find . find_all ( 'a' , { 'class' : 'entry js-blc js-blc-t-heart btn-heart btn btn-heart-circle js-heart-button' }) rentries = [] try : for e , u in zip ( entries , usernames ): image = \"https://weheartit.com/images/\" + u [ 'data-entry-id' ] + \"/original.jpg\" id = int ( u [ 'data-entry-id' ]) entry = Entry ( id = id , title = e [ 'title' ], username = u [ 'data-hearter-username' ], entry = e [ 'href' ], image = image ) rentries . append ( entry ) except : raise NoPostsFound ( \"Could not find any entries related to that search query. Try again with a different one or check your search query.\" ); return return rentries def search_users ( self , query : str ) -> list [ User ]: ''' returns a list of ``User``s according to search query. The number of users is limited to top 40 users thats relevant to your search query. The ``User`` object will return users usernames, names and links to their avatars. + params + + query: `str`: search query that you'd like to search. ``` whi = WeHeartIt() hearters = whi.search_users(\"sophie\") for user in hearters: print(user.name, user.username, user.avatar) ``` ''' res = requests . get ( f \"https://weheartit.com/search/users?query= { query } \" ) find = bs ( res . text , features = \"lxml\" ) entries = find . find_all ( 'span' , { 'class' : 'text-overflow' }) users = [] for e in entries : e = bs ( str ( e ), features = \"lxml\" ) name = ( e . find ( 'span' , { 'class' : 'text-big' })) . text . strip () username = ( e . find ( 'small' )) . text [ 1 :] avatar = find . find ( 'img' , { 'alt' : f ' { name } ' , 'class' : 'avatar' }) avatar = avatar [ 'src' ] users . append ( User ( username = username , name = name , avatar = avatar )) if len ( users ) == 0 : raise NoUsersFound ( \"weheartpy could not find any users related to that search query. Try again with a different one or check your query. \\n \" ); return return users","title":"Module weheartpy.weheartpy"},{"location":"reference/weheartpy/weheartpy/#classes","text":"","title":"Classes"},{"location":"reference/weheartpy/weheartpy/#weheartit","text":"class WeHeartIt ( ) View Source class WeHeartIt () : ' '' the WeHeartIt class. eg. instantiating the class: `` whi = WeHeartIt() popular_posts = whi.popular() `` '' ' def __init__ ( self ) -> None : err = requests . get ( \"https://weheartit.com\" ) try : err . raise_for_status () except requests . HTTPError : raise ConnectionError ( f \"The API cannot connect to weheartit.com \\n REASON: {err.reason} \\n help: Try checking your network connection.\" ) self . status = err . status_code self . url = err . url def popular ( self ) -> list [ Entry ] : ' '' return a list of ``Entry`` objects of the popular images. - - ``` whi = WeHeartIt() entries = whi.popular() for entry in entries: print(entry.id) print(entry.username) print(entry.image) print(entry.url) ``` '' ' res = requests . get ( \"https://weheartit.com\" ) res = bs ( res . text ) images = res . find_all ( 'a' , { 'class' : 'entry js-blc js-blc-t-heart btn-heart btn btn-heart-circle js-heart-button' } ) entries = [] for img in images : image = f \"https://data.whicdn.com/images/{img['data-entry-id']}/original.jpg\" entry = Entry ( id = int ( img [ 'data-entry-id' ] ), username = img [ 'data-hearter-username' ] , entry = img [ 'href' ] , image = image ) entries . append ( entry ) if len ( entries ) == 0 : raise NoPostsFound ( 'No posts were found. This might be a useragent or a website problem. Are you sure weheartit.com still has a popular images section? \\n SOURCE: WeHeartIt.popular | match case \"low\" \\n ' ) return return entries def search_collections ( self , query : str ) -> list [ Collection ] : ' '' return a list of ``Collection`` objects resulting from the query. ``` from weheartpy import WeHeartIt whi = WeHeartIt() cocs = whi.search_collections(\"anime pfp\") for c in cocs: print(c.title, c.link) ``` '' ' res = requests . get ( f \"https://weheartit.com/search/collections?query={query}&sort=most_recent\" ) find = bs ( res . text ) atags = find . find_all ( 'a' , { 'class' : 'js-blc js-blc-t-collection collection-name text-overflow-parent' } ) collections = [] for a in atags : link = a [ 'href' ] pop = bs ( str ( a )) title = pop . find_all ( 'span' , { 'class' : 'text-primary' } ) title = ( title [ 0 ] ). text username = pop . find_all ( 'small' ) username = ((( username [ 0 ] ). text ). replace ( 'by @' , '' )). strip () collections . append ( Collection ( username = username , title = title , link = link )) if len ( collections ) == 0 : raise NoCollectionsFound ( \"the API could not find any collections with that query! Try with something else.\" ) return return collections def search_entries ( self , query : str , sort : str = None ) -> list [ Entry ] : ' '' returns a list of ``Entry`` objects according to your search query. + params + + sort: `str`: sort the type of entries. Only one option `most_popular`. When left empty the API will go for most recent instead. ``` whi = WeHeartIt() entries = whi.search_entries(\"mean girls\", sort=\"most_popular\") for entry in entries: print(entry.image, entry.url, entry.username) ``` '' ' url = f \"https://weheartit.com/search/entries?query={query}\" if sort == None else f \"https://weheartit.com/search/entries?query={query}&sort=most_popular\" res = requests . get () find = bs ( res . text , features = \"lxml\" ) entries = find . find_all ( 'a' , { 'class' : 'js-entry-detail-link js-blc js-blc-t-entry' } ) usernames = find . find_all ( 'a' , { 'class' : 'entry js-blc js-blc-t-heart btn-heart btn btn-heart-circle js-heart-button' } ) rentries = [] try : for e , u in zip ( entries , usernames ) : image = \"https://weheartit.com/images/\" + u [ 'data-entry-id' ] + \"/original.jpg\" id = int ( u [ 'data-entry-id' ] ) entry = Entry ( id = id , title = e [ 'title' ] , username = u [ 'data-hearter-username' ] , entry = e [ 'href' ] , image = image ) rentries . append ( entry ) except : raise NoPostsFound ( \"Could not find any entries related to that search query. Try again with a different one or check your search query.\" ); return return rentries def search_users ( self , query : str ) -> list [ User ] : ' '' returns a list of ``User``s according to search query. The number of users is limited to top 40 users thats relevant to your search query. The ``User`` object will return users usernames, names and links to their avatars. + params + + query: `str`: search query that you' d like to search . ` `` whi = WeHeartIt() hearters = whi.search_users(\"sophie\") for user in hearters: print(user.name, user.username, user.avatar) `` ` ' '' res = requests.get(f\"https://weheartit.com/search/users?query={query}\") find = bs(res.text, features=\"lxml\") entries = find.find_all(' span ', {' class ': ' text - overflow '}) users = [] for e in entries: e = bs(str(e), features=\"lxml\") name = (e.find(' span ', {' class ': ' text - big '})).text.strip() username = (e.find(' small ')).text[1:] avatar = find.find(' img ', {' alt ': f' { name } ', ' class ': ' avatar '}) avatar = avatar[' src '] users.append(User(username=username, name=name, avatar=avatar)) if len(users) == 0: raise NoUsersFound(\"weheartpy could not find any users related to that search query. Try again with a different one or check your query. \\n \"); return return users","title":"WeHeartIt"},{"location":"reference/weheartpy/weheartpy/#methods","text":"","title":"Methods"},{"location":"reference/weheartpy/weheartpy/#popular","text":"def popular ( self ) -> list [ weheartpy . models . Entry ] return a list of Entry objects of the popular images.","title":"popular"},{"location":"reference/weheartpy/weheartpy/#-","text":"whi = WeHeartIt () entries = whi . popular () for entry in entries : print ( entry . id ) print ( entry . username ) print ( entry . image ) print ( entry . url ) View Source def popular ( self ) -> list [ Entry ] : ' '' return a list of ``Entry`` objects of the popular images. - - ``` whi = WeHeartIt() entries = whi.popular() for entry in entries: print(entry.id) print(entry.username) print(entry.image) print(entry.url) ``` '' ' res = requests . get ( \"https://weheartit.com\" ) res = bs ( res . text ) images = res . find_all ( 'a' , { 'class' : 'entry js-blc js-blc-t-heart btn-heart btn btn-heart-circle js-heart-button' } ) entries = [] for img in images : image = f \"https://data.whicdn.com/images/{img['data-entry-id']}/original.jpg\" entry = Entry ( id = int ( img [ 'data-entry-id' ] ), username = img [ 'data-hearter-username' ] , entry = img [ 'href' ] , image = image ) entries . append ( entry ) if len ( entries ) == 0 : raise NoPostsFound ( 'No posts were found. This might be a useragent or a website problem. Are you sure weheartit.com still has a popular images section? \\n SOURCE: WeHeartIt.popular | match case \"low\" \\n ' ) return return entries","title":"-"},{"location":"reference/weheartpy/weheartpy/#search_collections","text":"def search_collections ( self , query : str ) -> list [ weheartpy . models . Collection ] return a list of Collection objects resulting from the query. from weheartpy import WeHeartIt whi = WeHeartIt () cocs = whi . search_collections ( \"anime pfp\" ) for c in cocs : print ( c . title , c . link ) View Source def search_collections ( self , query : str ) -> list [ Collection ]: ''' return a list of ``Collection`` objects resulting from the query. ``` from weheartpy import WeHeartIt whi = WeHeartIt() cocs = whi.search_collections(\"anime pfp\") for c in cocs: print(c.title, c.link) ``` ''' res = requests . get ( f \"https://weheartit.com/search/collections?query= { query } &sort=most_recent\" ) find = bs ( res . text ) atags = find . find_all ( 'a' , { 'class' : 'js-blc js-blc-t-collection collection-name text-overflow-parent' }) collections = [] for a in atags : link = a [ 'href' ] pop = bs ( str ( a )) title = pop . find_all ( 'span' , { 'class' : 'text-primary' }) title = ( title [ 0 ]) . text username = pop . find_all ( 'small' ) username = ((( username [ 0 ]) . text ) . replace ( 'by @' , '' )) . strip () collections . append ( Collection ( username = username , title = title , link = link )) if len ( collections ) == 0 : raise NoCollectionsFound ( \"the API could not find any collections with that query! Try with something else.\" ) return return collections","title":"search_collections"},{"location":"reference/weheartpy/weheartpy/#search_entries","text":"def search_entries ( self , query : str , sort : str = None ) -> list [ weheartpy . models . Entry ] returns a list of Entry objects according to your search query. params sort: str : sort the type of entries. Only one option most_popular . When left empty the API will go for most recent instead. whi = WeHeartIt () entries = whi . search_entries ( \" mean girls \" , sort = \" most_popular \" ) for entry in entries : print ( entry . image , entry . url , entry . username ) View Source def search_entries ( self , query : str , sort : str = None ) -> list [ Entry ] : ' '' returns a list of ``Entry`` objects according to your search query. + params + + sort: `str`: sort the type of entries. Only one option `most_popular`. When left empty the API will go for most recent instead. ``` whi = WeHeartIt() entries = whi.search_entries(\"mean girls\", sort=\"most_popular\") for entry in entries: print(entry.image, entry.url, entry.username) ``` '' ' url = f \"https://weheartit.com/search/entries?query={query}\" if sort == None else f \"https://weheartit.com/search/entries?query={query}&sort=most_popular\" res = requests . get () find = bs ( res . text , features = \"lxml\" ) entries = find . find_all ( 'a' , { 'class' : 'js-entry-detail-link js-blc js-blc-t-entry' } ) usernames = find . find_all ( 'a' , { 'class' : 'entry js-blc js-blc-t-heart btn-heart btn btn-heart-circle js-heart-button' } ) rentries = [] try : for e , u in zip ( entries , usernames ) : image = \"https://weheartit.com/images/\" + u [ 'data-entry-id' ] + \"/original.jpg\" id = int ( u [ 'data-entry-id' ] ) entry = Entry ( id = id , title = e [ 'title' ] , username = u [ 'data-hearter-username' ] , entry = e [ 'href' ] , image = image ) rentries . append ( entry ) except : raise NoPostsFound ( \"Could not find any entries related to that search query. Try again with a different one or check your search query.\" ); return return rentries","title":"search_entries"},{"location":"reference/weheartpy/weheartpy/#search_users","text":"def search_users ( self , query : str ) -> list [ weheartpy . models . User ] returns a list of User s according to search query. The number of users is limited to top 40 users thats relevant to your search query. The User object will return users usernames, names and links to their avatars. params query: str : search query that you'd like to search. whi = WeHeartIt () hearters = whi . search_users ( \" sophie \" ) for user in hearters : print ( user . name , user . username , user . avatar ) View Source def search_users ( self , query : str ) -> list [ User ] : ' '' returns a list of ``User``s according to search query. The number of users is limited to top 40 users thats relevant to your search query. The ``User`` object will return users usernames, names and links to their avatars. + params + + query: `str`: search query that you' d like to search . ` `` whi = WeHeartIt() hearters = whi.search_users(\"sophie\") for user in hearters: print(user.name, user.username, user.avatar) `` ` ' '' res = requests.get(f\"https://weheartit.com/search/users?query={query}\") find = bs(res.text, features=\"lxml\") entries = find.find_all(' span ', {' class ': ' text - overflow '}) users = [] for e in entries: e = bs(str(e), features=\"lxml\") name = (e.find(' span ', {' class ': ' text - big '})).text.strip() username = (e.find(' small ')).text[1:] avatar = find.find(' img ', {' alt ': f' { name } ', ' class ': ' avatar '}) avatar = avatar[' src '] users.append(User(username=username, name=name, avatar=avatar)) if len(users) == 0: raise NoUsersFound(\"weheartpy could not find any users related to that search query. Try again with a different one or check your query. \\n \"); return return users","title":"search_users"}]}